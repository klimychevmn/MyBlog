-- phpMyAdmin SQL Dump
-- version 4.5.1
-- http://www.phpmyadmin.net
--
-- Host: 127.0.0.1
-- Generation Time: Mar 15, 2016 at 03:46 PM
-- Server version: 10.1.10-MariaDB
-- PHP Version: 7.0.3

SET SQL_MODE = "NO_AUTO_VALUE_ON_ZERO";
SET time_zone = "+00:00";


/*!40101 SET @OLD_CHARACTER_SET_CLIENT=@@CHARACTER_SET_CLIENT */;
/*!40101 SET @OLD_CHARACTER_SET_RESULTS=@@CHARACTER_SET_RESULTS */;
/*!40101 SET @OLD_COLLATION_CONNECTION=@@COLLATION_CONNECTION */;
/*!40101 SET NAMES utf8mb4 */;

--
-- Database: `blog`
--

-- --------------------------------------------------------

--
-- Table structure for table `articles`
--

CREATE TABLE `articles` (
  `id` int(11) NOT NULL,
  `title` varchar(255) NOT NULL,
  `date` date NOT NULL,
  `author` varchar(255) NOT NULL,
  `content` text NOT NULL
) ENGINE=InnoDB DEFAULT CHARSET=utf8;

--
-- Dumping data for table `articles`
--

INSERT INTO `articles` (`id`, `title`, `date`, `author`, `content`) VALUES
(1, 'Самый первый пост', '2000-01-01', 'admin', 'Самый первый пост'),
(2, 'Про кофе и про Web, или почему PHP — велосипед', '2013-07-14', '@eternal_why', 'Нет-нет. Статья не про отношение к написанию велосипедов на PHP, а именно о том, что PHP — велосипед сам по себе. И нет, автор не пытается примкнуть к тем неленивым, которые хотят PHP пнуть. Вернее будет сказать, что пнуть автор собирается не только PHP. Осторожно: статья крайне многословная.<br/>\r\n<br/>\r\nPHP — достаточно уникальное явление современности. PHP обладает низким порогом вхождения, PHP хорош тем, что тра-ля-ля, тра-ля-ля. Вы и сами всё это знаете лучше меня. Именно на PHP крутится огромное количество сайтов и блогов, создатели которых не имеют порою совершенно никакого понятия о программировании. Joomla и Wordpress тому яркое подтверждение. И я говорю именно о создателях таких сайтов, а не об авторах этих движков. Однако, без какого-либо сарказма, отмечу, что PHP действительно хорош во многом, и лично я не могу считать его абсолютным злом в байт-коде. Просто многие, ну очень-очень многие почему-то забывают, что PHP — всего лишь шаблонизатор.<br/>\r\n<br/>\r\n<br/>\r\nНу да. Просто это очень, очень продвинутый шаблонизатор. Настолько продвинутый, что в нём есть даже ООП, неймспейсы, и много всяких-разных полезных и удобных штук. И даже уже есть встроенный веб-сервер, говорят. Не знаю точно, лично не проверял, ибо уже не слежу.<br/>\r\n<br/>\r\nДумаю, уместно будет попросить прощения у всех и каждого на случай, если какое-либо суждение покажется кому-то оскорбительным или неуважительным. Не было и в мыслях. Скорее, наоборот: я искренне преклоняюсь перед самоотверженно пишущими часто весьма и весьма хороший код людьми, и безмерно уважаю такой труд и таких людей. Простите великодушно и не судите строго. Просто смотрю на всё, что сегодня происходит в IT и, в частности, в WEB, и молчать становится всё сложнее. Поэтому статья представляет из себя полуфилософские размышления и соображения, и не содержит абсолютно никаких практических рекомендаций. Но, тем не менее, очень хочется надеться, что некоторый практический смысл мне, всё-таки, донести удастся. Навеян данный опус многочисленными публикациями на хабре и не только — про веб и про его закат, про HTML5/CSS/JS и не только, про шаблонизаторы, фреймворки и проектирование; а также комментариями ко всему этому.<br/>\r\n<br/>\r\nНу и, как водится, немного об авторе. Автор не тим-лид, не СЕО, не джуниор и не сеньор. И вообще, карьера автора в качестве программиста пока как-то не сложилась в силу разных причин, хотя предпосылки для этого были. В частности, в предсовершеннолетнем возрасте автор получал изрядное удовольствие от декомпиляции спектрушных игрушек и программирования в мнемонике Z80. Но, в дальнейшем, личностные перемены и отсутствие перспектив в том месте и в то время отодвинули всё это в разряд хобби, тому же сильно поспособствовала неудачная попытка осилить FoxPro 2.6 на незнакомой платформе с незнакомым, и совершенно непонятным, после ассемблера, ООП от MS. Но то, что в будущем стали называть громкой аббревиатурой IT, не отпускало, в результате много лет было прожито в небольшой госконторе в качестве сисадмина. Однако, мысли о программировании провели автора через различной степени погружение в VB/VBA/VBS, Delphi, MS VC++, ужасное и непонятое MFC, после чего автор на какое-то время обрёл покой с Borland C++ и его VCL. После чего пошла в ход литература уже по методикам программирования и проектированию систем и интерфейсов. Потом был PHP, ActionScript (который 3.0), Python и, разумеется, святая троица HTML/CSS/JS. Java долго не принимался в расчёт по идеологическим соображениям, но и это, как оказалось, не является неизменным. Повторюсь (это важно), все выше названные аббревиатуры и названия изучались и пробовались исключительно в качестве хобби; практические применения (в том числе и на коммерческой основе) случались нечасто, но всё же случались. Так что чукча, всё-таки, больше читатель, нежели писатель. На данный момент госконтора осталась в прошлом ввиду перехода автора на самообеспечение на поприще (дежа вю!) программирования, в том числе и web-ориентированного. И да, сваливать надо было раньше.<br/>\r\nТакже автора часто ругают друзья за игнорирование принципов <a href="http://habrahabr.ru/company/alconost/blog/182986/">JFDI</a> (автор уважительно относится к народной мудрости из разряда «тише едешь» и «семь раз отмерь»), а также за крайнюю многословность.<br/>\r\nИ последнее: автор использует обращение к себе в третьем лице исключительно в контексте самоиронии, ибо всё вышеперечисленное видится ему весьма забавным (но и в чём-то грустным тоже). Но достаточно об этом.<br/>\r\n<br/>\r\nИтак, шаблонизатор. Задумайтесь на минутку, а что же всё-таки делает штука, которую принято считать шаблонизатором? В большинстве случаев шаблонизатор, грубо говоря, на входе принимает шаблон (или, что чаще, ссылку на файл шаблона) и набор переменных, а выдаёт готовый текст в виде заполненного значениями переменных шаблона. Также нередко может использоваться шаблон «по умолчанию». В принципе, часто можно и переменные не передавать, тогда на выходе будет чистый шаблон. Также некоторые шаблонизаторы умеют сами запрашивать из базы данных какие-то данные и вставлять их в шаблон, однако, такая вольность многими считается недопустимой ввиду несоответствия концепциям MVC. Думаю, многие уже догадались, к чему я клоню. <br/>\r\nСобственно, ничего нового я не сказал, ибо PHP и задумывался как шаблонизатор. Он и работает, как шаблонизатор: получил запрос — обработал — вернул ответ — спим (или конец работы). Я совершенно не против его такового использования. Но я совершенно против использования PHP как инструментария для создания шаблонизаторов. Также я против написания на PHP фреймворков и CMS, в особенности, с применением ООП (да ещё если иерархия классов разрастается до тысяч штук).<br/>\r\n<br/>\r\nОднако, это всё всего лишь вступление. Сказка только начинается, ибо проблема здесь гораздо шире и глубже. Но давайте немного отвлечёмся и посмотрим на велосипеды. В буквальном смысле. Руль, педали да пара колёс. Как Вы думаете, каков мировой рекорд скорости езды на велосипеде? До недавнего момента я даже не догадывался. Однако, простейший поиск выводит на цифру <a href="http://en.wikipedia.org/wiki/Fred_Rompelberg">268 км/ч</a>. Только вдумайтесь: оказывается, на велосипеде можно поехать со скоростью, на которую не всякий автомобиль способен! Конечно, и не на всякой дороге можно такую скорость развить, да и различные ухищрения потребуются.<br/>\r\n<br/>\r\nТеперь посмотрим, кто же велосипедами пользуется:<br/>\r\n<ul>\r\n<li>Спортсмены — с ними всё понятно, спорт — это спорт. Он такой, потому что так сложилось исторически. </li>\r\n<li>Дети — эти ещё не доросли либо до физиологической возможности управления автомобилем, либо до юридической. В общем, малы ещё. Только велосипеды и остаются. </li>\r\n<li>Люди, не имеющие финансовой возможности для приобретения автомобиля. </li>\r\n<li>Люди, идеологически приверженные данному виду транспорта по различным соображениям (экология, здоровье, опять же, деньги, но уже «из принципа»). </li>\r\n</ul><br/>\r\nИ в каких ситуациях:<br/>\r\n<ul>\r\n<li>Велотреки/олимпийские трассы. </li>\r\n<li>Просто «погонять»/прокатиться. </li>\r\n<li>«Сгонять по-быстрому» куда-нибудь недалеко. </li>\r\n<li>При отсутствии альтернатив можно и подальше поехать, но это уже будет непросто. </li>\r\n<li>Ещё на нём можно привезти или прикатить что-нибудь слишком тяжёлое для ручной переноски. </li>\r\n</ul><br/>\r\n<br/>\r\nПеречисленное выше может также комбинироваться в различных вариациях. Как видим, применение велосипеда в практическом плане в массах используется нечасто (большая часть Европы и Азии с этим не согласится, но на то есть причины). Оно и понятно — зачем, если можно комфортнее и быстрее? К тому же, поехать на велосипеде, скажем, на деловую встречу тоже не каждый может себе позволить. Потому что для этого нужна достаточная смелость и некоторое пренебрежение к комфорту (банально потеешь, когда педали крутишь). Да и человека в строгом костюме при галстуке с кейсом, и, при этом, на велосипеде, мне представить сложновато. Но опять же — оно не везде так, где-то это и нормально.<br/>\r\n<br/>\r\nИтак, что мы имеем для сопоставления двух сущностей из разных миров:<br/>\r\n<ul>\r\n<li>и заиметь, и поехать — просто и доступно</li>\r\n<li>но поехать недалеко и небыстро</li>\r\n<li>поехать можно и далеко, но это будет совсем небыстро и утомительно</li>\r\n<li>поехать можно и быстро, но недолго, и уже, в общем-то, недёшево, и ещё более утомительно. И, скорее всего, недалеко. Да и не везде этот фокус пройдёт.</li>\r\n</ul><br/>\r\nПоследний пункт наиболее нагляден. Применительно к PHP, пожалуй, можно исключить «недолго», а вот в остальном — практически полное идеологическое сопоставление. Нужен «колпак»/«воздушный коридор», который придётся организовывать специально для этого случая, и который, скорее всего, никогда больше не пригодится. Нужна гладкая дорога, которая есть не везде. Впрочем, гладкая дорога для любого наземного транспорта предпочтительна. И очень желательно, чтобы было «не в горку». Хотя, возможно, с «недолго» я поспешил. Большой или очень большой проект на PHP без принятия специальных мер по его стабильности всё равно рано или поздно рухнет. Не хватит либо железа, либо способностей программиста. Тут уж сами решайте, что на что похоже, но мне нравится такая аналогия: <br/>\r\n<ul>\r\n<li>БД — это как дорога. Чем более плоская, тем лучше. </li>\r\n<li>WEB-сервер — как сопротивление воздуха. Чем меньше он тупит от хитов, тем лучше.</li>\r\n<li>Кэши различного рода — это «колпак» и сопровождающая его техника — без этого, конечно, можно, но с ней лучше.</li>\r\n</ul><br/>\r\nВ принципе, здесь автора можно упрекнуть в предвзятости — ведь веб-сервер нужен для любого сайта, написанного на любом языке! Этаа, онооо, канешна, эээ… да… — мнётся автор. Но. Автор ведь обещал пнуть не только PHP. Давайте посмотрим на процесс с другой стороны. Со стороны конечного пользователя (например, посетителя сайта) и его браузера. А так же на некоторые моменты из жизни HTTP. Можно посмотреть ещё со стороны заказчика сайта, но об этом мы не будем. Потому что заказчик если и будет выбирать, то только из того, что есть. Пока же допустим, что разработчик сайта — его же и хозяин. Такое тоже бывает.<br/>\r\n<br/>\r\nВ общем смысле, основная задача конечного пользователя сводится к получению нужной (а иногда и необходимой) информации. В частном — «тыцнуть в сцылку» (вбить руками/скопировать/вставить адрес в строку) и лицезреть вожделенное. И ему, в подавляющем большинстве случаев, совершенно пофигу, какое там железо, какой там софт. Ему даже на маршрут до сервера пофиг, и на весь HTTP вместе со всеми его ответами и состояниями. Он вообще не имеет представления, что там, зачем и почему. Из чего явно следует, что ни мускул, ни пых, ни даже нгинкс (я знаю, что оно не так произносится) ему не нужен. Ему нужна «инфа». И точка. И единственное, что видит пользователь — это картинки/текст/видео/звук. Кто-то ещё на дизайн/удобство обращает внимание, но не все. Кто-то ещё смотрит на скорость загрузки/реакции сайта, но, опять же, не все.<br/>\r\n<br/>\r\nА на что же смотрит разработчик сайта? В наиболее полном смысле — на всё. Но для этого нужно иметь представление и о сисадминьстве, и о программизьме, и о вебь-дизайне («юзабилити» предлагаю включить в дизайн для простоты, хотя часто это не так). Таких не так уж и много, у нас в моде разделение труда. В результате иногда эти три ветви власти настолько независимы друг от друга, что просто диву даёшься, как оно вообще умудряется работать-то. Давайте просто перечислим в географически/временном порядке путь от запроса до страницы в том виде, в котором это существует на данный момент. Уверен, большинство тех, кто в теме, знает это лучше меня, и, если навру — поправят. Но я в общем смысле, чтобы оно предстало перед глазами во всей красе, так сказать. Итак:<br/>\r\n<ul>\r\n<li>пользователь щёлкает по ссылке</li>\r\n<li>браузер выясняет адрес сервера (либо берёт из кэша, если не первый раз. Но первый раз это сделать всё равно придётся).</li>\r\n<li>браузер формирует GET|POST (реже иные HTTP) -запрос к web-серверу и осуществляет его.</li>\r\n<li>web-сервер: <ul>\r\n<li>либо анализирует запрос (например, на предмет «статика/динамика») и, если статика, выдаёт файл</li>\r\n<li>либо просто вызывает скрипт</li>\r\n</ul> </li>\r\n<li>скрипт разбирается, статика ли, динамика ли. Можно вообще файл на лету сгенерировать. И начинает собирать текст ответа. В стандартных случаях применительно к PHP эта процедура протекает как-то так: <ul>\r\n<li>читается с диска (либо берётся из кэша файловой системы) скрипт, парсится, исполняется</li>\r\n<li>в зависимости от содержимого скрипта тут обычно начинают читаться (браться из кэша) конфиги, шаблоны, всё это начинает парситься, компилироваться (ну или браться из кэша PHP) и исполняться; осуществляются запросы к БД за данными, а порой и за шаблонами (по возможности здесь тоже кешируется)</li>\r\n<li>на основании всего прочтённого и исполненного формируется готовый текст ответа</li>\r\n</ul> </li>\r\n<li>скрипт возвращает веб-серверу plain-текст ответа</li>\r\n<li>web-сервер (в общем случае) посылает браузеру заголовок и ответ скрипта</li>\r\n<li>браузер разбирает ответ сервера и решает что с ним делать: <ul>\r\n<li>если HTMLсотоварищи — парсит и отображает/исполняет</li>\r\n<li>если медийная шняга, опять же, отображает/проигрывает, сам или с помощью плагинов</li>\r\n</ul> </li>\r\n<li>profit! (если не 404 или ещё какая пакость, но не будем об этом; у нас ведь всё хорошо)</li>\r\n</ul><br/>\r\nВесьма стандартная процедура, как видите. Ничего необычного, ничего фатального, всё в стандартных рамках. Я бы и сам не парился, но. Меня постоянно посещает такое ощущение, что «что-то здесь не так». Попробуем разобраться. Даже беглый осмотр выявляет одно часто употребляющееся выражение: «берётся из кэша». А если вы попробуете пробежаться по форумам, посвящённым повышению производительности сайта на PHP — Вас в этот самый кэш так натыкают, что Вы будете везде искать, чего бы ещё закэшить-то. А на Ваш вопрос «зачем кешить» Вам очень популярно объяснят, насколько это полезно. Приведу свои любимые формулировки:<br/>\r\n — А как без кэша-то?<br/>\r\n — Узкое место любого сайта — БД! Кэшируй всё что только можно!<br/>\r\n — Мэмкэшд рулит!<br/>\r\nИ только самые сердобольные, тяжко вздохнув, в сотый или тысячный раз прочтут тебе краткую лекцию про то, что PHP — это интерпретатор, что оно компилируется каждый раз, но это можно закэшить, насколько медленна работа с БД и ваще, поставь nginx для static-proxy, а скрипты пусть apache крутит. А ещё юзай куки, сессии и локальные хранилища, потому что HTTP…<br/>\r\n<br/>\r\nПриведу ещё один неприметный, на первый взгляд, списочек. Небольшой такой списочек технологий, которые нужны для того, чтобы легко и просто создать сайт (здесь я от PHP всё-таки отстану, ибо здесь уже начинается кроличья нора):<br/>\r\nСерверная сторона:<br/>\r\n<ul>\r\n<li>web-сервер, а то и несколько</li>\r\n<li>скриптовый (как правило, но не обязательно) язык</li>\r\n<li>сервер баз данных</li>\r\n</ul><br/>\r\nКлиентская сторона:<br/>\r\n<ul>\r\n<li>HTML</li>\r\n<li>CSS</li>\r\n<li>JS</li>\r\n<li>нередко и AS(Flash) и не только</li>\r\n</ul><br/>\r\nВсё это так или иначе завязано на HTTP over TCP over IP over Ethernet (правда, внутри одного сервера могут использоваться сокеты межпроцессного взаимодействия). Семь (!!!) технологий для одного сайта! Нет, ну это правда нормально? Даже нет, не так. Для одного цикла запрос-ответ все они всё равно нужны и всё равно работают. Даже если это запрос к страничке типа «я и собака моя», которая меняться будет раз в полгода — семь разных технологий, которые сами себя постоянно парсят и кэшируют, это правда нормально? Конечно! — ответят профессионалы. И обоснуют свой ответ политиками и спецификой shared-хостингов и т.д. и т.п. И, кстати, будут правы. Применительно к сегодняшнему дню. Потому что на текущий день именно такая схема показала себя самой гибкой и живучей. Более того, в комментариях подкинут ещё пару-тройку, а то и больше. Я по любому что-то забыл или ещё хуже, не знал.<br/>\r\nНо вот только лично мне это нормальным не представляется. И вот теперь я попробую свою позицию объяснить.<br/>\r\n<br/>\r\nЛирическое отступление номер один. Около шести лет назад автор познакомился с веб-технологиями в виде сопровождения и дописывания сайтов, построенных на PHP/MySQL. Сначала, разумеется, это было весьма диковинно и ново, но очень быстро пришло осознание того факта, что смешанный в кучу HTML и JS, выводимый то через echo, то через print, то просто вне &lt;?php ?&gt; — это не так уж и весело. Параллельно с этим вдруг оказалось, что написать браузерную онлайн-игру — это не только круто и прибыльно, но ещё и чертовски легко! Знакомо? :) В результате состоялся запуск некоей браузерной онлайн игры, на якобы open-source движке, написанном (разумеется, не автором, а неизвестной третьей стороной) на PHP, после заглядывания внутрь кода которого шевелились волосы, а практика работы с БД в количестве порядка 180-ти запросов на каждый клик просто ужасала. И основная масса запросов реализовывала то, чего так не хватает в PHP over HTTP применительно к подобным проектам — текущее состояние игрока и игрового процесса. Здесь будет уместно поболезненней пнуть автора за никудышный выбор технологий, да и поделом ему. Разумеется, код переписывался, много чего было изменено в механике игры, но преодолеть главный недостаток движка мы тогда так и не смогли — требовалось его полное переписывание с нуля. Что и было задумано и начато. И самым большим нашим тогдашним желанием было организовать какого-нибудь «демона», который бы управлял БД и её содержимым с целью унифицировать и упростить механику движка. Примерно в то же время в мускуле появились хранимые процедуры и планировщик, и нам показалось, что это, наконец, решит все наши проблемы. Взять C или Python в то время у нас сначала не хватило смелости, потом — времени, а ещё через некоторое время стало ясно, что планируемое создание не будет приносить желаемого дохода ввиду своей специфики, и все лучшие мысли были отложены на чарующее «потом». Которое, пока что, ещё не наступило. Ключевой момент вышеописанного: <i>именно отсутствие встроенных механизмов для работы с текущим состоянием и их костыльная реализация своими силами ускорили неизбежный крах того движка.</i><br/>\r\n<br/>\r\nЛирическое отступление номер два. Автор — в некоторой степени идеалист, перфекционист и мечтатель. Автор любит с утра испить свежесваренного в турке кофе и немного помечтать. В том числе и о том, чтобы кофе варился как-нибудь сам. Но, поскольку данный конкретный образец мечтаний не носит совершенно никакого прикладного характера, автор любит пофантазировать на эту тему какую-нибудь очередную ахинею, в порядке бреда. Возможно, чтоб размять мозги или просто пострадать фигнёй — я точно не знаю. Так вот, в то_самое_утро я лежал и рассуждал примерно так:<br/>\r\nну, допустим, налить воды и засыпать кофе в турку можно и с вечера. Газовая плита с пьезоэлектроподжигом — им можно щёлкнуть по таймеру релюшкой, это несложно. Остаётся придумать простой способ поворачивать ручку крана конфорки, чтоб открывать и закрывать газ… И вот тут-то меня и осенило. Мы настолько привыкли к этому привычному процессу, что совершенно перестали замечать детали процесса, и мыслить стали скачками через проработанные когда-то давно ступеньки. Что нужно для того, что бы сварить кофе? Турка, вода, кофе, открыть газ, поджечь газ… Стоп! Причём тут вообще газ? Для того, чтобы нагреть воду. Так вот — нам шашечки или ехать? <i>Нам нужен открытый газ или всё-таки нам нужна горячая вода?..</i><br/>\r\n<br/>\r\nВот, собственно, по этой схеме все мы обычно и рассуждаем. Устоявшиеся, отработанные, хорошие или просто удобные практики и алгоритмы мы оставляем для себя как образец успешного решения жизненных задач, и в аналогичных случаях пытаемся применить именно эти, зарекомендовавшие себя технологии. Это одно из основных оснований основ нашего мышления, и это хорошо, и часто именно этот подход будет являться подходящим решением поставленной задачи. Но не всегда. Вот вам абстрактный пример, который в более конкретных вариациях я имел счастье наблюдать сотни раз в обычной жизни, в том числе и среди собственных действий. Допустим, нам нужно отнести товарищу воды попить. Мы быстро в уме прикидываем условия: количество, дальность, удобство переноски, и находим вполне себе нормальное решение. Берём кружку, наливаем воду, несём приятелю. Приятель счастлив — мы тоже. Задача решена, все довольны. Образец решения создан. Через пару часов приятель просит повторить — мы не задумываясь берём эту же кружку и повторяем процедуру. Всё хорошо. Образец прошёл первую стадию закрепления — подтверждение истинности. Через недельку друг опять заглядывает на огонёк, и — по тому же сценарию. Образец готов к промышленному применению. И когда через месяц пара друзей попросит воды — мы смело берём две кружки и проблем ну просто никаких! Промышленное применение в действии, масштабирование осуществлено, проверено и испытано. Отныне в нашем сознании «пить воду» будет железобетонно проассоциировано с «из кружки». Капкан готов. Потому что однажды к нашему очагу неожиданно заваливается шумная компашка человек пятнадцать, на улице июль и +30 по Цельсию. Короче, хабраэффект. От семи до десяти рейсов с кружками плюс потенциальная возможность несколько из них разбить. Вместо того, чтобы взять несколько пустых кружек, просто надев их ручками на пальцы одной руки (их ведь теперь не нужно нести исключительно горизонтально, они ведь пустые) и бутыль/графин/кувшин с водой — в другую руку. Примерно так, собственно, и рождаются идеи, действительно оригинальные — достаточно отступить на шаг-два в размышлениях и посмотреть на ситуацию со стороны. В противном случае мы начинаем как-то упрощать себе задачу упереть 15 кружек с водой за одну ходку. Можно, например, поставить их все на один поднос. А можно и скотчем смотать… И тут не дай Бог решить эту задачу успешно. Потому что через какое-то время возникнет задача принести из колодца воды литров десять, и подошедший сосед будет долго ржать, наблюдая за нами, набирающими воду из колодца кружку за кружкой, и аккуратно, соблюдая композицию и инкапсуляцию, составляющими эти кружки в заготовленную для этих целей сумку, специально заточенную под горизонтальное_размещение_кружек. И, в ответ на его ехидный кивок в сторону стоящего рядом с колодцем ведра, нам захочется его ударить очень сильно чем-нибудь тяжёлым, например, этим самым ведром. Потому что очень неприятно и больно осознавать, что он прав, называя нас идиотами…<br/>\r\n<br/>\r\nВ своё время я с большим энтузиазмом наблюдал за эффектным шествием AS3, но <a href="http://habrahabr.ru/post/84892/">пришёл мистер ай и всё испортил</a>. Конечно, давайте обругаем древнюю технологию трёхлетней давности за её тормознутость и громоздкость, не будем пытаться её оптимизировать, договорившись и утряся технологические вопросы с парой десятков конечных производителей железа и софта, а вместо этого возьмём новенькие десятилетние наработки на основе плоского текста с поддержкой малоэффективной раскраски и суперскоростного интерпретируемого языка, который уже почти без проблем добавляет на наши и без того великолепные страницы капельку интерактива, если, конечно, воспользуетесь вот этим отличным фреймворком и поштучно обойдёте все ваши динамически видоизменяющиеся примитивы, и уже совсем скоро сделаем из всего этого конфетку, буквально пара лет осталась!.. Очень, очень сильно уважаю дядю Стива за много что, но конкретно в этом вопросе я с ним не согласен. Хотя, не исключаю, что он и в самом деле хотел как лучше. Но адобы то ли не так поняли, то ли просто повелись, и, в итоге, фактически, профукали веб…<br/>\r\n<br/>\r\nЛирическое отступление номер три. На моей стене висит относительно новый телевизор с технологией Smart, встроенным браузером и поддержкой клавиатуры/мыши. Но попытки зайти на какой-нибудь видеохостинг в 90% случаев терпят неудачу. Для начала — сложно просто набрать адрес, если опечатался, ведь стрелки клавиатуры управляют курсором мыши(!!!). Но, даже если удастся успешно зайти на сайт — не факт, что доберётесь до просмотра фильма. Либо не удастся попасть курсором в фильм из-за сумасшедшего скроллинга, либо сдохнет браузер под тяжестью заботливо понатыканных владельцем сайта JS-скриптов, и всё придётся начинать сначала. Люди, разрабатывающие хвалёные Smart-приложения, похоже, ни разу не видели клавиатур, ибо символьная раскладка экранной клавиатуры почему-то, в большинстве случаев, алфавитная. Там даже иногда есть кнопка переключения языка ввода, но не работает ни одна устоявшаяся клавиатурная комбинация клавиш, для этого обычно используемая. Да что там язык — сама клавиатура в этих приложениях работает не всегда. И, вообще-то, тот факт, что там как раз и используется тот самый флэш — не значит ровным счётом ничего. Просто потому, что где-то работает так, как надо, а где-то — нет. И что, это — прогресс?<br/>\r\n<br/>\r\nКогда я крутил тот самый AS3 — я, опять же, ужасался от того, что на нём пишут. Ибо самые известные игрушки-казуалки созданы на основе примеров из обучающих книг, а графика во многих хуже, чем «спектрушная» тридцатилетней (!!!) давности, про анимацию вообще молчу. Но это, к счастью, проблема не языка, а кривых рук. Потому что к моменту относительно широкого распространения различных движков качество местами улучшилось. В то время немалое количество талантливых ребят, в том числе и наших соотечественников, делали на AS3 шикарные вещи, в том числе реализовывали практически полноценное 3D и физику, потому что до десятой версии флэшплеера третьего измерения не было. В 10-й версии таки прикрутили координату Z, хотя и не всё было безоблачно, но важно не это. Важно то, что в Adobe осознали, что существует весьма явный и уже почти фатальный недостаток, и приняли меры по его устранению. К слову, вот вам <a href="http://yadi.sk/d/3D0eQSr-6kdLG">простенький экзерсис двухлетней давности</a> размером 4825 байт. Исходный код содержит около 250 строк кода; используются только встроенные классы, никаких сторонних движков. Орбиты эллиптические, положение планет рассчитывается по средней аномалии (движение ускоренное, по Кеплеру). Никаких оптимизаций ни по скорости исполнения, ни по размеру не проводилось. Вот и забацайте-ка мне что-нибудь аналогичное по размеру передаваемого клиенту кода и скорости исполнения на том же голом JS хоть с canvas''ом, хоть как. Или на CSS, гы-гы. Может, тогда я и признаю торжество HTML5&сотоварищи…<br/>\r\n<br/>\r\nТеперь давайте коротко взглянем на эволюцию программиста и программирования на языках, отличных от PHP для платформ, отличных от HTML (этих мы рассмотрим чуть позже). Обычно путь развития программиста проходит через несколько ключевых для него этапов:<br/>\r\n<br/>\r\nШаг 00. Пишем «hello world». Ура! Я программист!<br/>\r\nШаг 10. Пишем Крутое Оконное Приложение. <br/>\r\nШаг 20. Чё-та как-то многа переменных, куча функций и переменных наклонирована копипастом. Исправлять в десяти местах уже надоело, надо что-то с этим делать.<br/>\r\nШаг 30. Ага! Надо использовать классы!<br/>\r\nШаг 40. Что-то классы у меня всё больше копипастятся, и править один фиг приходится в десяти местах.<br/>\r\nШаг 50. Ага! Шаблоны проектирования решат все мои проблемы!<br/>\r\nШаг 99. Блин, каким же я был идиотом… Вот же, всё же просто… <br/>\r\nШаг 100. Дзен.<br/>\r\n<br/>\r\nНомера шагов и названия методик выбраны почти произвольно. Важны не они сами по себе, а факт смены программистом парадигм мышления. По крайней мере, так было у меня, и у людей, с которыми я знаком и код которых я видел. Правда, на мой критический взгляд, никто из них до 99-го шага ещё не добрался, равно как и я сам. Да и не так уж много у меня знакомых программистов. Но вот когда заглядываешь в код авторов некоторых фреймворков/библиотек/программ — оторопь берёт и появляется ощущение, что люди давным-давно ушагали за какой-нибудь пятисотый шаг…<br/>\r\n<br/>\r\nЕсть у меня одно беспокоящее меня наблюдение. В различных учебниках есть рекомендации не оглядываться в процессе проектирования программ на аппаратные возможности вычислительной техники, а также призывы не задумываться, почему это работает именно так, а просто использовать это. Мне это представляется в корне неверным для подготовки качественного программиста. И подтверждений этому я встречал множество — большинство действительно хороших программистов имеют неслабое представление о том, как работает «вообще это всё», иногда вплоть до ассемблера и уровня TCP. Но вот что примечательно: подобная рекомендация действительно ценна для воспитания monkeypatcher''а. Оно и понятно. Дрессировка животных обычно производится подобным способом: не важно, зачем и почему, важно сделать именно это и будет вкусно. И вот на этой неприятной ноте мы переходим к заветной парочке PHP/HTML.<br/>\r\n<br/>\r\nЯ лично склонен условно делить PHP''шников на две больших категории: тех, кто знает другие языки программирования (для таких, как правило, PHP не был первым языком, хотя и наоборот тоже бывает), и тех, кто не знает кроме PHP ничего. Первая категория часто развивается по предыдущему сценарию, и к ним у меня вопросов нет — они и на PHP обычно пишут хороший код и используют его грамотно и обоснованно. Но вот вторая категория — там всё иначе. Вообще всё. Потому что, проходя развитие по первому сценарию, люди часто изначально используют напрямую только одну-две непривязанных к конкретному языку технологии (например, консоль или WinAPI/X11), и причинно-следственные связи не рвутся: вот они, аргументы командной строки, а вот они и в коде, пользуемся. Чего никак нельзя сказать о второй категории.<br/>\r\n<br/>\r\nПотому что люди, которые до PHP не программировали вообще — оказываются один на один с готовой, большой, уже работающей и очень непонятной системой. С одной стороны, вот тебе echo ''hello world'' — браузер — F5 — вот оно, а с другой — не совсем ясно, как оно туда попало и почему не обновилось само. Нет, основные понятия типа «положить файл в корень вебсервера», конечно, усваивается, но вопросы «откуда у вебсервера корень?» и «как он выглядит вообще-то?» часто остаются без должных разъяснений с туманной надеждой на восполнение этого пробела в будущем. Со временем количество таких непонятных мест только растёт, туда добавляются всякие цээсэс/джээс/хэтэакцесс/оопэ/шаблоны/шрифты/жипеги, внутренности которых не особо понятны, но (и это очень важно) — всем этим, оказывается, определённо можно пользоваться вообще не задумываясь о том, что, почему и как. Со временем парадигма «не задумываться» иногда оказывается превалирующей, и тогда это совсем печально. Где-то когда-то какие-то психологи установили, что восприятие нового текста человеком прекращается на том месте, где он встретил непонятное слово. В таком случае самым правильным будет вернуться к этому слову, разъяснить его смысл, и продолжить. В случае с веб-технологиями (и чаще всего в вебе начинают именно с PHP) — непонятных слов очень много. Невероятно много, для некоторых — так почти все. Но: если начать объяснять всю цепочку от запроса до браузера через веб-сервер по тцпипу — до собственно программирования мы дойдём очень нескоро. И поэтому тут начинается враньё. Либо преподаватели (в широком смысле — это могут быть и старшие товарищи, и друзья-форумчане, и лекторы из видео-уроков) врут обучаемым, что потом всё станет ясно, либо сами ученики начинают врать себе и учителям (потому что признаться в непонимании стыдно): «Да лан, тут я всё понял». «Да нифига ты не понял», — машут рукой учителя и выдают следующую порцию обучения. Со временем обучаемые настолько свыкаются с состоянием «немного недопонял, но давай так», что в сознании накапливается полнейшая свалка из понятий, методов, форматов и всего, чего только можно.<br/>\r\n<br/>\r\nНа выходе мы можем получить «специалиста», который уже несколько лет программирует на PHP, но до сих не может внятно объяснить, как файл, залитый на один сервер, оказывается в браузере при запросе к другому серверу. Нет, в целом-то, он, канешна, панимает, но вот если попросить разъяснить — на выходе будет нечто среднее между «как-то так» и «да какая разница». <br/>\r\n<br/>\r\nДополнительная головная боль для PHP — это ООП в любом смысле и всякие иные плюшки времени исполнения. И эволюция PHP-программиста в итоге будет несколько отличаться от вышеописанных ста шагов до дзена. Потому что, с одной стороны, все пхпшники знают, что сценарий отработает, схлопнется и всё забудет, а с другой — пишут код так, как будто это софт, работающий непрерывно годами и веками. Тщательно продумывая структуру классов, статических методов, реализуя интерфейсы и даже (!!!) сигналы, они плодят километры кода. Апофеоз начинается с реализацией «ленивой загрузки» — ведь все же понимают, что этот код может оказаться и неисполненным, так чего его зазря инклудить? Подвоха не чувствуется ещё? Этот код, быть может, никогда и не исполнится, но он написан! И на его написание было потрачено время, силы, нередко и деньги…<br/>\r\n<br/>\r\nИ если для программиста на языке с длительным временем исполнения единожды проинициалированная переменная в доброй половине случаев может быть использована хоть через год работы программы, то в PHP это всё инициализируется, инстанцируется и композиционируется буквально в ответ на каждый чих от браузера пользователя, нередко и в ответ на ajax-запрос, после чего всё мгновенно рушится и забывается. Автор иногда немножко тормоз, и осознание этого факта для него однажды стало неслабым ударом по психике.<br/>\r\n<br/>\r\nРазумеется, никакой Америки я снова не открыл, но почему я об этом говорю и почему считаю это важным. Потому что общая каша в головах многих программистов мешает им абстрагироваться от всего процесса и поразмыслить о <s>сути бытия</s> том, чего ради всё это нагорожено. И в ответ на попытки им это втемяшить они, привыкшие к тому, что «это всё равно так и этого не изменить», отказываются что-либо понимать. Иногда потому, что иного пути, кроме как браузер — веб-сервер — PHP — БД — PHP — веб-сервер — браузер просто не представляют. Ну а поскольку на выходе в любом случае всё равно HTML с плюшками, то и это переходит в разряд неизменных и непреложных истин, не подлежащих доказательству аксиом. И, поскольку PHP в наши дни в большинстве, и именно для него нужен именно отдельный_веб-сервер, то и программирующие на других языках начинают к отдельным_веб-серверам привязываться, ибо они всё равно установлены и настроены, да и зачем изобретать колесо? И правда, зачем? Всё же, вроде бы, и так прекрасно работает?<br/>\r\n<br/>\r\nЧтобы всё-таки уже ответить на этот вопрос, коснёмся ещё одной темы. А именно: отдельный_веб-сервер. Что он делает обычно и с чего всё начиналось? Иными словами, зачем оно сделано именно так? Дело в том, что <a href="http://ru.wikipedia.org/wiki/CERN_httpd">первый веб-сервер</a> был создан очень давно. Оперативной памяти тогда было мало и она была дорогая. Файлы тогда тоже были маленькими, и графические элементы для оформления дизайна практически не использовались. Не было ни PHP, ни JS, ни CSS. Был только голый HTML. Браузер тогда был не средством утоления информационного голода, а новой программой, запустив которую, можно было некоторую информацию получить (при наличии подключения к интернету, который был тоже очень маленьким и медленным тогда). А веб-сайты были не способом выпендриться (хотяя… :)), а способом поделиться некоторым количеством информации. Дисковые массивы тоже не отличались большой ёмкостью, но всё-таки, были дешевле оперативки. Хранить файлы в оперативной памяти тогда просто считалось (да и на самом деле было) невозможным, даже если они использовались часто. К тому же скорость подключения тогда измерялась единицами и десятками килобит. Поэтому первые веб-серверы в ответ на запрос пользователя начинали по нескольку десятков байт в секунду считывать файл с жёсткого диска сервера и по кусочкам передавать его клиенту через сеть. И передача одного файла не всегда занимала меньше одной секунды. Да. С тех пор прошло чуть более двадцати лет. Всё изменилось. Любой тогдашний средний сервер обзавидовался бы, наверно, современному среднему смартфону по любому параметру, будь то ёмкость ОЗУ, частота ЦП, да и ёмкость ПЗУ, наверно, тоже. А то и разрешению экрана. <br/>\r\n<br/>\r\nНо мы по-прежнему храним файлы на дисках, читаем их веб-серверами и скармливаем браузерам пачками. Только понапридумывали ещё кучу всяких красивостей и удобств вроде rich internet application со скриптовыми языками. И всё это поверх технологий двадцатилетней давности. Придумали не напрягать бедного пыха статическими файлами и раздавать их отдельно веб-сервером. Умные люди, уставшие от несовершенства CSS даже придумали LESS и SASS, а может, и ещё что-нибудь есть. И теперь дилемма — где и когда это компилировать? То ли на сервере, то ли на клиенте. То ли кэшировать, то ли перекомпилировать после каждого изменения и складывать в статику? Но почему-то никто не хочет посмотреть, а что же такое есть кэш по сути своей, и как веб-сервер статику раздаёт. Хотя каждый использует формулировки типа «файлы всё равно закэшатся системой и не будут перечитываться с диска каждый раз». Ну сделайте уже этот последний шаг! Ведь всем уже видно, что файлы, будучи закэшированн?');
INSERT INTO `articles` (`id`, `title`, `date`, `author`, `content`) VALUES
(6, 'Список полезных инструментов для php разработчика', '2009-09-02', 'Дмитрий', 'PHP один из самых широко используемых языков для создания вебсайтов. PHP фреймворки, такие как Zend, CakePHP, CodeIgniter и т.д и open source классы и библиотеки упростили разработку.<br/>\r\nНезависимо от того, являетесь ли вы опытным разработчиком или новичком, инструменты, которые вы используете, имеют прямое влияние на вашу продуктивность. Здесь собран список действительно полезных утилит и расширений для PHP разработчиков, которые помогут ускорить разработку, и улучшит итоговое качество кода.<br/>\r\n<br/>\r\n<h1>Акселераторы</h1><br/>\r\n<a href="http://eaccelerator.net/">eAccelerator</a><br/>\r\nБесплатный свободный PHP акселератор, оптимизатор, и динамический кэш. Он увеличивает производительность PHP скриптов, кешируя их в их скомпилированном виде. Также оптимизация увеличивает скорость работы скриптов. eAccelerator обычно уменшает нагрузку на сервер и увеличивает скорость PHP кода в 1-10 раз.<br/>\r\n<a href="http://www.php-accelerator.co.uk/">ionCube PHP Accelerator</a><br/>\r\nionCube PHP Accelerator это легко устанавливаемое PHP Zend расширение, которое кеширует PHP код, и способное существенно ускорить PHP скрипты без изменений в самом коде.<br/>\r\n<a href="http://www.iis.net/extensions/WinCacheForPHP">Windows Cache Extension for PHP</a><br/>\r\nМодуль для IIS7 выполняющий функции PHP акселератора.Поддерживает PHP 5.2 и 5.3. Кеширует php байткод в память<br/>\r\n<a href="http://pecl.php.net/package/APC">Alternative PHP Cache</a><br/>\r\nБесплатная и открытая система для кэширования предкомпилированных PHP скриптов, позволяет значительно увеличить производительность PHP скриптов выполняющихся из под mod_php.<br/>\r\n<br/>\r\n<h1>Билд системы</h1><br/>\r\n<a href="http://phing.info/">Phing</a><br/>\r\nБилд система основанная Apache Ant. Позволяет делать все, что можно делать с традиционными билд системами, такими как GNU make. Использует простой XML для билд файлов и расширяемые PHP классы задач. Позволяет запускать PHPUnit and SimpleTest юнит тесты, делать обработку файлов (т.е. замены токенов, XSLT трансформацию и т.д.), операции с файловой системой, интерактивная сборка проекта, выполнение SQL кода, CVS/SVN операции, создание PEAR пакетов, и многое другое.<br/>\r\n<br/>\r\n<h1>Код</h1><br/>\r\n<a href="http://www.beautifyphp.com/">BeautifyPHP</a><br/>\r\nBeautify PHP полностью бесплатный сервис, форматирующий PHP код в соответствии со стандартами PEAR.<br/>\r\n<a href="http://pear.php.net/package/PHP_Beautifier">PHP Beautifier</a><br/>\r\nЭта программа переформатирует файлы PHP 4 и PHP 5 автоматически. <br/>\r\n<a href="http://www.phpobjectgenerator.com/">PHP Object Generator (POG)</a><br/>\r\nOpen source генератор PHP кода, автоматически генерирующий объектно-ориентированные классы (PHP4/PHP5) для доступа к базе данных с CRUD методами. <br/>\r\n<a href="http://uml2php5.zpmag.com/en/index.php">UML2PHP5</a><br/>\r\nUML2PHP5 это плагин разработанный для приложения построения диаграмм <a href="http://live.gnome.org/Dia">DIA</a>. Автоматически генерирует PHP код, соответствующий диаграммам.<br/>\r\n<a href="http://www.dpriver.com/">Instant SQL Formatter</a><br/>\r\nInstant SQL Formatter — бесплатный онлайн сервис для форматирования SQL кода. Также может переводить SQL код в C#, Java, PHP, DELPHI и другие языки (в виде строк). Позволяет вывести список объектов базы в SQL коде, таких как таблицы, колонки, функции.<br/>\r\n<a href="http://www.phpmyedit.org/">phpMyEdit</a><br/>\r\nРедактор таблиц MySQL и генератор кода PHP. Основные возможности phpMyEdit: генерация кода изменения таблиц; добавление записей, изменение, просмотр, копирование и удаление; сортировка, фильтрация и разбивка на страницы для таблиц; запросу в другие таблицы (связь один ко многим); конфигурация прав доступа; различные возможности навигации; дизайн, настраиваемый с помощью CSS; логгирование действий пользователей; многоязычность.<br/>\r\n<a href="http://www.raizlabs.com/software/phpobfuscator/">PHP Obfuscator</a><br/>\r\nОбфусцирует PHP код. Не требует дополнителных установленных на сервере библиотек и компонентов. Позволяет обфусцировать функции, переменные и удалять пробелы.<br/>\r\n<a href="http://www.codeeclipse.com/">Code Eclipse</a><br/>\r\nPHP обфускатор, превращающий обычный PHP код в ужасный, нечитаемый код с минимальными потерями в скорости выполнения и без всяких потерь в совместимости.<br/>\r\n<br/>\r\n<h1>База данных</h1><br/>\r\n<a href="http://phpdataservices.codeplex.com/">PHP Toolkit for ADO .NET Data Services</a><br/>\r\nПозволяет PHP разработчикам обращаться к источникам данных созданных с помощью ADO .NET Data Services. Целью проекта является предоставление такой же функциональности, как и библиотеки .NET.<br/>\r\n<a href="http://propel.phpdb.org/">Propel</a><br/>\r\nPropel это ORM фреймворк для PHP5. Дает доступ к базе данных с помощью специальных объектов, имеющих простое API для хранение и получения данных.<br/>\r\n<a href="http://adodb.sourceforge.net/">ADOdb</a><br/>\r\nОбъектно-ориентированная библиотека, написанная на PHP, которая позволяющая абстрагироваться от операций с конкретной базой данных ради портабельности. Моделировалась с Microsoft’s ADO, но имеет множество улучшений делающий данную библиотеку уникальной ( таких как Pivot таблицы, поддержка Active Record, генерация HTML для разбиения на страницы recordsets со ссылками на следующую и предыдущую страницу, кешируемые recordsets, HTML menu generation, и т.д.). Поддерживает большое количество баз данных: MySQL, PostgreSQL, Interbase, Firebird, Informix, Oracle, MS SQL, Foxpro, Access, ADO, Sybase, FrontBase, DB2, SAP DB, SQLite, Netezza, LDAP, и стандартные ODBC, ODBTP.<br/>\r\n<a href="http://www.doctrine-project.org/">Doctrine</a><br/>\r\nDoctrine это ORM for PHP 5.2.3+, который создан на основе слоя абстракции базы (DBAL). Одним из ключевых преимуществ является возможность писать запросы к базе данных на объектно-ориентированном диалекте SQL — Doctrine Query Language (DQL), созданном под впечатлением от Hibernate HQL. DQL предоставляет разработчикам мощную, гибкую альтернативу SQL, которая не требует лишнего написания повторного кода.<br/>\r\n<br/>\r\n<h1>Отладка</h1><br/>\r\n<a href="http://www.xdebug.org/">Xdebug Debugger and Profiler Tool</a><br/>\r\nXdebug это расширение для отладки php-скриптов, которое написал Derick Rethans, один из разработчиков языка PHP. Xdebug предоставляет следующую информацию: стек вызовов функций, распределение памяти. Возможности Xdebug: профайлинг, анализ покрытия кода, защита от бесконечной рекурсии, интерактивная отладка скриптов. You should also check: <a href="http://code.google.com/p/webgrind/">Webgrind</a> – веб-интерфейс для профайлинга Xdebug, написанный на PHP, <a href="http://www.bluestatic.org/software/macgdbp/">MacGDBp</a> – Mac OS X клиент, который позволяет отлаживать PHP приложения при помощи Xdebug.<br/>\r\n<a href="http://www.firephp.org/">FirePHP</a><br/>\r\nFirePHP дает возможность посылать отладочные сообщения в консоль Firebug с помощью вызова php методов. Вся информация посылается через заголовки X-FirePHP-Data, тем самым не пересекаясь с основным контентом страниц.<br/>\r\n<a href="http://www.php-debugger.com/">DBG – PHP Debugger and Profiler</a><br/>\r\nDBG это полноценный, интерактивный PHP отладчик. Он может работать на тестовом или/и рабочем сервере и позволяет отлаживать скрипты локально или удаленно, из IDE или из консоли.<br/>\r\n<a href="http://www.php-debug.com/">PHP Debug</a><br/>\r\nПомогает в отладке PHP кода, показывает путь выполнения скрипта, отображает все переменные, время выполнения, включенные файлы, выполненные запросы, watch переменные… Эта информация собирается во время выполнения скрипта, и отображается по его завершению и потом может быть использована в любой момент.<br/>\r\nЕще: <a href="http://phpdebuglib.de/">Debuglib</a>, <a href="http://krumo.sourceforge.net/">Krumo</a><br/>\r\n<br/>\r\n<h1>Разработка</h1><br/>\r\n<a href="http://matrix.squiz.net/developer/tools/php_cs">PHP CodeSniffer</a><br/>\r\nPHP CodeSniffer это PHP5 скрипт проверяет код на соответствие стандартам кодирования. Может помочь предотвратить распространённые семантические ошибки, допускаемые разработчиками. Легко интегрируется с SVN для проверки кода перед коммитом. <br/>\r\n<a href="http://phpdoc.org/">phpDocumentor</a><br/>\r\nАналог Javadoc, написанный на PHP, phpDocumentor может быть вызван из командной строки или веб-интерфейса для создания документации из php кода. phpDocumentor поддерживает связь между документацией, соединяя документа уровня пользователя, такие как туториалы и создание подсвеченного кода с кросссылками на обычную PHP документацию.<br/>\r\n<a href="http://www.stack.nl/~dimitri/doxygen/index.html">Doxygen</a><br/>\r\nDoxygen — это кроссплатформенная система документирования исходных текстов, которая поддерживает PHP (а также множества других языков).<br/>\r\nDoxygen генерирует документацию на основе набора исходных текстов и также может быть настроен для извлечения структуры программы из недокументированных исходных кодов. Возможно составление графов зависимостей программных объектов, диаграмм классов и исходных кодов с гиперссылками.<br/>\r\n<a href="http://www.pdepend.org/">PHP Depend</a><br/>\r\nPHP Depend это анализатор и измерительный инструмент, который может предоставить множество полезный информации об PHP проекте. PHP Depend генерирует большое количество метрик, полученные значения могут быть использованы для определения качества проекта и его частей, нуждающихся в рефакторинге.<br/>\r\n<a href="http://phplangeditor.mozdev.org/">phpLangEditor</a><br/>\r\nFirefox add-on упрощающий перевод языков файлов и переменных в PHP скриптах.<br/>\r\n<br/>\r\n<h1>IDE & Редакторы</h1><br/>\r\n<a href="http://netbeans.org/">NetBeans</a><br/>\r\nNetBeans — бесплатная, быстрая, кросс-платформенная IDE, которая хорошо понимает язык PHP. В ней приятно писать PHP-код, потому что присутствует все необходимые для этого инструменты — подсветка, дополнение кода из всех подключенных файлов, браузер классов PHP, всплывающая документация по стандартным функциям и так далее. NetBeans умеет скачивать и закачивать файлы на удаленные сервера по FTP и SFTP, имеет развитый SQL-терминал и полностью автоматизирует работу с SVN или CVS. <br/>\r\n<a href="http://www.aptana.com/php">Aptana PHP Development Environment</a><br/>\r\nIDE снабжена средствами контекстной подсказки, автодополнения кода, подсветки и проверки синтаксиса, имеет встроенный отладчик и автогенератор типовых блоков кода. Среда поддерживает разработку Ajax-приложений, имеет средства для визуальной навигации по коду, поддержания списка задач (Todo) и подготовки документации к проекту. Интегрированный в среду web-сервер позволяет мгновенно оценить результат работы. Встроенные средства тестирования поддерживают возможность оценки отображения подготовленного проекта в различных версиях web-браузеров. Aptana PHP выполнена в виде модуля для Eclipse или для специализированной среды Aptana Studio, построенной на базе Eclipse.<br/>\r\n<a href="http://www.phpeclipse.com/">PHPEclipse</a><br/>\r\nPHPEclipse – это плагин для эклипс со следующими возможностями: подствека синтаксиса, парные скобки, сворачивание кода, автодополнение кода, интеграция php документации, шаблоны кода, поддержка DBG и XDebug, поддержка CVS & SVN++.<br/>\r\n<a href="http://www.zend.com/products/studio/">Zend Studio</a><br/>\r\nZend Studio — профессиональная среда для разработки и отладки веб-проектов. Отличительной особенностью программы является возможность удаленной отладки и профайлинга. В состав Zend Studio в качестве опции входит пакет PHP вместе с обширным списком предварительно скомпилированных расширений. Также в пакет среды входит Zend Optimizer, являющийся серверным модулем для запуска закодированных с помощью Zend Encoder и Zend SafeGuard Suite скриптов, а также немного их ускоряющий. В седьмой версии Zend Studio появилась поддержка PHP 5.3, интеграция с Zend Framework и Zend Server, улучшено редактирование исходного кода и различные улучшения производительности программы.<br/>\r\n<a href="http://phpanywhere.net/">PHPanywhere</a><br/>\r\nPHPanywhere – это онлайн PHP-редактор. Работает на Ext JS. Все необходимые функции присутствуют — подсветка, кодировки и т.д. Пользование сервисом совершенно бесплатно и требует лишь регистрации. <br/>\r\n<a href="http://www.jcxsoftware.com/vs.php">VS.Php For Visual Studio</a><br/>\r\nVS.Php — это интегрированная среда разработки, основанная на Visual Studio IDE и позволяющая разрабатывать, создавать, отлаживать и внедрять PHP приложения на профессиональном уровне, используя все возможности, предлагаемые VisualStudio.Net. Редактор PHP-кода обладает большой функциональностью, предоставляя доступ к встроенным функциям PHP, а так же написанным функциям и классам..<br/>\r\n<a href="http://www.nusphere.com/">NuSphere PhpED</a><br/>\r\nNuSphere PhpED — это профессиональная интегрированная среда обработки, предназначенная для того, чтобы формировать приложения с использованием баз данных и PHP, HTML, XML, CSS. Устойчивый редактор кода, отличная система подсветки кода в языках PHP, XML, XHTML, HTML, CSS и javascript, мощный PHP отладчик, профилировщик и издатель — все в одном.<br/>\r\nПрограмма также включает интегрированную базу данных и клиенты CVS, сервисы SOAP, валидатор HTML и инструментальные средства Форматера Кода, поддержка работы с Smarty, редактор Unicode, SFTP поддерживается для безопасных загрузок и закачек, Telnet, SSH терминалы для удаленного администрирования, поддержка функциональных возможностей MySQL, Oracle, MSSQL SQLite, Interbase, поддержка анализа ошибок, графический интерфейс пользователя полностью настраиваемый, анализатор PHP кода и многое другое<br/>\r\n<a href="http://www.eclipse.org/pdt/">Eclipse PDT</a><br/>\r\nPDT (PHP Development Tools) — плагин Eclipse, предназначенный для PHP-разработчиков. Является намного более чем просто достойной бесплатной заменой Zend Studio и NuSphere PhpED. Дистрибутив pdt-all-in-one включает в себя платформу Eclipse и все необходимые плагины для разработки на языке PHP<br/>\r\n<a href="http://www.jetbrains.net/confluence/display/WI/Web+IDE+EAP">Jetbrains Web IDE EAP</a><br/>\r\nJetBrains Web IDE это IDE для веб программирования. Она построена на основе платформы JetBrains IDE Framework.Web IDE доступна в двух вариантах: в стандартный вариант включена поддержка HTML, CSS, Javascript. В PHP Developer edition добавляется поддержка PHP и SQL.<br/>\r\n<br/>\r\nЕще: <a href="http://www.nusphere.com/products/phped.htm">PhpED</a>, <a href="http://www.phpedit.com/en">PHPEdit</a>, <a href="http://www.mpsoftware.dk/phpdesigner.php">phpDesigner</a>, <a href="http://www.activestate.com/komodo/">Komodo IDE</a>, <a href="http://www.activestate.com/komodo_edit/">Free Komodo Edit</a>, <a href="http://macromates.com/">TextMate</a>, <a href="http://www.ankord.com/phpxedit.php">PHP Expert Editor</a>, <a href="http://notepad-plus.sourceforge.net/ru/site.htm">Notepad++</a>, <a href="http://www.flos-freeware.ch/notepad2.html">Notepad2</a>, <a href="http://www.codelobster.com/">Code Lobster</a><br/>\r\n<br/>\r\n<h1>Безопасность</h1><br/>\r\n<a href="http://php-ids.org/">PHP Intrusion Detection System (PHPIDS)</a><br/>\r\nPHPIDS — это легкая в использовании, хорошо структурированная, быстрая система обнаружения атак. На данный момент умеет ловить всевозможные виды XSSы, SQL инъекции, расщепления запроса, проход по директориям, RFE/LFI, DoS и LDAP инъекции. Справляется с обфусцированными атаками на базе юникодов, кодировок и т.п. Подключается к проекту как библиотека, принимает на вход массив со всеми входными данными, которые требуют проверки, возвращает объект с информацией об обнаруженных во входных данных попытках атаки и степени риска по каждой из них, на основе набора проверенных и оттестированных правил каждой атаке сопоставлен рейтинг ее опасности. Это позволит легко сохранять статистику по атакам или отсылать уведомления для команды разработчиков.<br/>\r\n<a href="http://phpsec.org/projects/phpsecinfo/index.html">PhpSecInfo</a><br/>\r\nPhpSecInfo добавляет эквивалент функции phpinfo() который предоставляет информацию о безопасности PHP окружения, и дает советы по улучшению. Это не замена техник безопасной разработки, и не делает никаких видов аудита кода или приложений.<br/>\r\n<br/>\r\n<h1>Установка</h1><br/>\r\n<a href="http://www.analogx.com/contents/download/network/phpconf.htm">PHPConfig</a><br/>\r\nГрафическая оболочка для настройки php через файл php.ini. Поддерживает всю стандартную функциональность, и имеет специальную закладку для плагинов.<br/>\r\n<a href="http://www.lighty2go.com/">Lighty2Go</a><br/>\r\nLighty2Go это портабельная версия LightTPD, MySQL & PHP (LiMP) для Windows.<br/>\r\n<a href="http://wiki.opensource.nokia.com/projects/PAMP">PAMP</a><br/>\r\nPersonal AMP – Apache, MySQL and PHP – комплект для мобильных телефонов S60.<br/>\r\n<a href="http://www.wampserver.com/en/index.php">WampServer</a><br/>\r\nПозволяет установить Apache, PHP и MySQL на Windows. В комплекте идет PHPMyAdmin для управления базой. WampServer умеет работать с различными версиями PHP, MySQL и Apache, и переключаться между ними.<br/>\r\n<a href="http://www.server2go-web.de/">Server2Go</a><br/>\r\nВебсервер не требующий инсталляции и работающий на носителях, защищенных от записи. Может быть использован прямо с CD диска, с USB флешки или просто папки на жестком диске без головной боли от конфигурирования PHP, Apache и MySQL.<br/>\r\n<a href="http://www.denwer.ru/">Denwer</a><br/>\r\nДжентльменский набор Web-разработчика («Д.н.w.р», читается «Денвер») — проект Дмитрия Котерова, набор дистрибутивов (Apache, PHP, MySQL, Perl и т.д.) и программная оболочка, используемые Web-разработчиками для разработки сайтов на «домашней» (локальной) Windows-машине без необходимости выхода в Интернет. Главная особенность Денвера — удобство при удаленной работе сразу над несколькими независимыми проектами и возможность размещения на Flash-накопителе.<br/>\r\n<a href="http://www.apachefriends.org/en/xampp.html">XAMPP</a><br/>\r\nXAMPP — это php, mysql, apache + perl модулем + filezilla + eAccelerator + еще различные плюшки. Существуют версии под Windows, Linux, MacOS и Solaris.<br/>\r\nЕще :<a href="http://www.appservnetwork.com/">AppServ</a><br/>\r\n<br/>\r\n<h1>Тестирование</h1><br/>\r\n<a href="http://www.phpunit.de/">PHPUnit</a><br/>\r\nPHPUnit является одним из семейства тестирующий фреймворков xUnit и упрощает написание тестов, так же как и их запуск и анализ результатов.<br/>\r\n<a href="http://simpletest.sourceforge.net/">SimpleTest</a><br/>\r\nSimpleTest это аналог JUnit/PHPUnit. Поддерживает mock объекты и может быть использован для автоматизации регрессионного тестирования веб приложений. Это возможно при помощи скриптабельного HTTP клиента, парсящего страницы и симулирующего такие вещи, как переход по ссылкам и отправка форм.<br/>\r\n<a href="http://code.google.com/p/bovigo/wiki/vfsStream">vfsStream</a><br/>\r\nvfsStream это обертка для потоков файловой, полезная при юнит тестировании для создания mock объектов файловой системы. Можно использовать совместно с любым тестирующим фреймворком, например SimpleTest или PHPUnit.<br/>\r\n<br/>\r\n<h1>Непрерывная интеграция </h1><br/>\r\n<a href="http://phpundercontrol.org/">phpUnderControl</a><br/>\r\nphpUnderControl это аддон для системы автоматической сборки CruiseControl, который содержит некоторые из лучших средств разработки на PHP. Проект нацелен на то, чтобы первые шаги с PHP и CruiseControl были как можно проще. К phpUnderControl прилагается утилита для модификации существующей развернутой системы CruiseControl.<br/>\r\n<a href="http://code.google.com/p/xinc/">Xinc</a><br/>\r\nXinc это сервер непрерывной интеграции написанный на PHP 5. Имеется встроенная поддержка Subversion и Phing (то есть и PHPUnit), и может быть легко модифицирован для поддержки других систем контроля версий и билд систем.<br/>\r\n<br/>\r\n<h1>Cheat Sheets</h1><br/>\r\n<a href="http://www.addedbytes.com/cheat-sheets/php-cheat-sheet/">PHP Cheat Sheet от AddedBytes</a><br/>\r\nОдностраничный cheat sheet, перечисляющий аргументы для функций форматирования дат, синтаксис регулярных выражений и распространенные функции.<br/>\r\n<a href="http://www.serversidemagazine.com/cheat-sheets/PHP5/">PHP 5 Online Cheat Sheet</a><br/>\r\nПриведение типов: Boolean, Integer, String, Array, Object/Class; Строки: функции, обработка; Массивы: функции, обработка; Классы: объявление, объявление методов, видимость; Дата/Время: функции, форматы; Предопределённые переменные: $_SERVER, $_FILES<br/>\r\n<a href="http://cakephp.org/downloads/Resources">The CheatSheet – CakePHP 1.2</a><br/>\r\nВключает CakePHP переменные конфига, глобальные функции, соглашения по оформлению кода, пути. Также содержит свойства, методы и каллбэки функций для Models, View, Controller и Helper классов.<br/>\r\n<a href="http://koivi.com/apache-iis-php-server-array.php">PHP $_SERVER Superglobal on Apache & IIS</a><br/>\r\nТаблица ключей, определенных в суперглобальной переменной $_SERVER на Apache и IIS. Данная таблица позволить оценить разницу между сервера в случае миграции с одного на другой.<br/>\r\n<a href="http://hasin.wordpress.com/2006/06/10/smarty-cheat-sheet-version-20/">Smarty Cheat Sheet</a><br/>\r\nСодержит подсказки для дизайнеров шаблонов Smarty.'),
(7, 'В защиту PHP', '2008-12-11', 'neudor', 'Недавно на stackoverflow была создана тема, в которой автор утверждал, что PHP неважнецкий язык и просил переубедить его. В качестве аргументов он привёл несколько доводов, которые были последовательно прокомментированы другим участником. Вольный перевод сего представлен ниже.<br/>\r\nЛично я полностью согласен с отвечающим и думаю, что всем ненавистникам PHP стоит с нижеследующим ознакомиться.<br/>\r\n<br/>\r\n<blockquote>PHP имеет противоречивое именование системных и библиотечных функций. Предсказуемые схемы именования имеют важное значение в любом языке.</blockquote><br/>\r\nЭто то, что я люблю и ненавижу одновременно. Однако по своей сути это утверждение верно. Почему некоторые двухсловные функции разделяются подчеркиванием, а некоторые нет? Почему $needle и $haystack иногда меняются местами? Это смешно. Но в конце концов действительно ли это так важно? Моя IDE с автоподстановкой и php.net всегда под рукой. Так что возможно это и является негативным фактором для PHP как языка. Но не мешает мне быть эффективным программистом.<br/>\r\n<blockquote>PHP разработчики постоянно отказываются от встроенных функций и низкоуровневой функциональности. Наглядным примером является отказ от возможности передачи в функцию параметров по ссылке. Это стало кошмаром для всех, кто использует, например, обратные вызовы.</blockquote><br/>\r\nЛично я считаю, что это не очень хорошая точка зрения. Такие изменения являются необходимым для эволюции языка, в особенности для используемого масштабно, как PHP. PHP предоставляет много возможностей чтобы стать плохим программистом, но точно так же разработчикам PHP проблематично устранить глупые конструкции языка, как, например, передача значения по ссылке. Ликвидация этой возможности стала одним из лучших решений, какое они когда либо принимали. Для новичка нет проще способа прострелить себе ногу, чем использовать эту «функцию».<br/>\r\n<br/>\r\n<blockquote>Отсутствие логики при редизайне. Вышеупомянутые «сокращения» сделали иногда невозможным указывать для функций значения по умолчанию. Этот баг пофиксен в PHP 5, но они же убрали передачу переменных по ссылке из PHP 4!</blockquote><br/>\r\nЯ не думаю что есть какой-то недостаток логики. Я думаю, вас сильно задело данное конкретное изменение и «во рту остался неприятный привкус». Изменения в языке зачастую становятся известны за месяцы, а то и годы до их реализации. Для перехода от 4 к 5 существует migration guide в котором описаны все различия. Передача параметров по ссылке была ужасной чертой, которая не даёт разработчику каких-либо преимуществ, не достижимых другими способами.<br/>\r\n<br/>\r\n<blockquote>Плохая реализация нэймспейсов (фактически из вообще нет). А сейчас, когда они появились, что будет использоваться в качестве разделителя? Бэкслэш! Символ, который повсеместно используется для экранирования, даже в PHP!</blockquote><br/>\r\nПо этому поводу у меня смешанные чувства. Часть меня думает, «какая разница, ведь символ экранирования не имеет смысла вне строки», а часть меня считает «наверное, они всё-таки могли бы придумать что-нибудь получше». Но могли ли они? Я не знаю, я не разработчик Zend. Однако тот факт, что у нас до 5.3 нет пространств имён является ужасным упущением.<br/>\r\n<br/>\r\n<blockquote>Чрезмерное применение пребразования типов приводит к ошибкам. У меня нет проблем с преобразованием, скажем, float в int и обратно. Но PHP (когда я последний раз проверял) с радостью попробует преобразовать массив в целое.</blockquote><br/>\r\nЯ считаю нормальным не согласиться с тем, как PHP делает это, но я не согласен с тем, что это делает язык «плохим».<br/>\r\n<br/>\r\n<blockquote>Плохая производительность при рекурсии. Рекурсия является принципиально важным инструментом для любого языка, она может делать сложные алгоритмы намного проще. Плохая поддержка этого просто непростительна.</blockquote><br/>\r\nPHP это DSL для Интернета. Я плотно работал с ним в течение 8 лет и пользовался рекурсией от силы 4 или 5 раз, как правило, для обхода директорий или XML. Это не тот подход, который часто нужен для веб-разработок. Я не оправдываю низкой производительности, но это гораздо больше академический вопрос, чем вопрос продуктивности. Если вам действительно нужна быстрая рекурсия, PHP &mdash; не ваш выбор.<br/>\r\n<br/>\r\n<blockquote>Функции нечувствительны к регистру. Я понятия не имею, о чём они думали в тот момент когда сделали это. Язык программирования это способ определить поведение как для компьютера, так для программиста, без двусмысленности. Нечувствительность к регистру вводит много неясностей.</blockquote><br/>\r\nЯ на 100% согласен с этим.<br/>\r\n<br/>\r\n<blockquote>PHP поощряет (практически требует) смешивание логики и представления. Да, вы можете написать код так, чтобы этого не было, но он действительно упрощает написание неправильного (с точки зрения проектирования) кода.</blockquote><br/>\r\nКак замечательно &mdash; люди жалуются на язык, который позволяет им применять любые системы вывода (об этом красноречиво свидетельствует количество и стиль шаблонизаторов для PHP) — ИЛИ — пропустить всё и просто выводить напрямую. Это совсем не делает PHP плохим. Это часть того, что делает PHP хорошим.<br/>\r\n<br/>\r\n<blockquote>Производительность PHP ужасна без кэширования. Скажите, кто-нибудь продаёт коммерческий продукт кэширования для PHP? Ах да, это делают сами разработчики PHP.</blockquote><br/>\r\nВы имеете в виду кэширование байткода (например, акселераторы), или кэширование вывода?<br/>\r\n<br/>\r\nЕсли первое, тогда я не думаю, что это важно для меня. Акселераторы свободны и их очень просто прикрутить. Мы могли бы спорить о том, почему они не является частью языка, но в конце концов, я не думаю, что это так уж важно.<br/>\r\n<br/>\r\nЕсли вы говорите о кэширования вывода то тут даже разговаривать не о чем. Любой веб-проект со значительными нагрузками нуждается в кэшировании. PHP здесь ни при чём.<br/>\r\n<br/>\r\nВ целом, я думаю, вы считаете PHP «плохим» языком в очень академическом понимании. А люди, использующие PHP, кодят на нём «to get things done».');

-- --------------------------------------------------------

--
-- Table structure for table `comment`
--

CREATE TABLE `comment` (
  `id` int(11) NOT NULL,
  `entry_id` int(11) NOT NULL,
  `date` text NOT NULL,
  `author` varchar(255) NOT NULL,
  `content` longtext NOT NULL
) ENGINE=InnoDB DEFAULT CHARSET=utf8;

--
-- Dumping data for table `comment`
--

INSERT INTO `comment` (`id`, `entry_id`, `date`, `author`, `content`) VALUES
(21, 2, '2016-03-15 15:38:07', 'vshemarov', 'Очень прошу: отметьтесь те, кто добросовестно прочитает весь текст с начала до конца. Интересно, много таких?'),
(22, 2, '2016-03-15 15:38:30', 'hell0w0rd', 'Дочитал до середины, хотя было желание остановиться после слов «я не программист». Какая ключевая мысль-то всего этого? Автор пробовал узнать сколько технологий используется в комьютере, на котором он набивал этот текст?\r\nPHP — возможно раньше и был шаблонизатором. Я не знаю историй других языков особо подробно, но представьте, если бы руби, например, изначально был придуман для описания логики микроволновок, и только для них, и спустя 10 лет, когда руби уже все умеет и могет, его используют в качестве бекэнд-сервера, на нем написан пакетный менеджер, и много всего хорошего, кто-то сидит и рассуждает «ха-ха, вы что, используете руби для бекэнда? Это же язык для микроволновок!»\r\nКстати стоит задуматься над тем, что php == шаблонизатор изначально успешный маркетинговый ход, всем хотелось динамических сайтов, вместо набора html, ровно как и название javascript и еще куча подобных вещей'),
(25, 7, '2016-03-15 15:40:48', 'IntenT', 'Чего еще ожидать от интепретируемого языка, который начинался как шаблонизатор для Perl? (-:\r\nОдин очень большой плюс PHP — низкий порог входа. \r\nОтсюда и его популярность.\r\n\r\nНо откуда планктону знать, что хорошо, а что плохо, если хорошего они не видели, а если и видели — то не поняли? (-:'),
(26, 7, '2016-03-15 15:41:01', 'ExcimeR', 'проблема быдлокода рождается от быдлокодеров а не от того что пхп такой плохой, на нём тоже можно красиво и грамотно писать.'),
(27, 7, '2016-03-15 15:41:15', 'taliban', 'а в какой версии появились юниты Вы вкурсе? а до 7 версии их не было, можно ли в таком случае считать что в 7 версии сделали костыль в виде неймспейсов? а в action script тоже ведь небыло пакетов изначально, можно ли их считать костылями? думайте что говорите, не все так просто как кажется на первый взгляд… создатели пхп проделывают грандиозные меры для улучшения ядра и у них это получается, не стоит плевать на них только потому что Вам этот язык не нравится… мне вот Java не нравится, но я никогда не скажу что она ужасна, хотя и у нее есть свои недостатк'),
(28, 1, '2016-03-15 15:41:49', 'Admin', 'Самый первый комментарий!');

-- --------------------------------------------------------

--
-- Table structure for table `form`
--

CREATE TABLE `form` (
  `id` int(11) NOT NULL,
  `date` text NOT NULL,
  `lastname` varchar(255) NOT NULL,
  `firstname` varchar(255) NOT NULL,
  `phone` int(20) NOT NULL,
  `email` text NOT NULL,
  `content` longtext NOT NULL
) ENGINE=InnoDB DEFAULT CHARSET=utf8;

--
-- Dumping data for table `form`
--

INSERT INTO `form` (`id`, `date`, `lastname`, `firstname`, `phone`, `email`, `content`) VALUES
(11, '2016-03-15 15:45:37', 'admin lastname', 'admin firstname', 123456789, 'admin@email.com', 'text writed by admin for test form');

--
-- Indexes for dumped tables
--

--
-- Indexes for table `articles`
--
ALTER TABLE `articles`
  ADD PRIMARY KEY (`id`);

--
-- Indexes for table `comment`
--
ALTER TABLE `comment`
  ADD PRIMARY KEY (`id`);

--
-- Indexes for table `form`
--
ALTER TABLE `form`
  ADD PRIMARY KEY (`id`);

--
-- AUTO_INCREMENT for dumped tables
--

--
-- AUTO_INCREMENT for table `articles`
--
ALTER TABLE `articles`
  MODIFY `id` int(11) NOT NULL AUTO_INCREMENT, AUTO_INCREMENT=9;
--
-- AUTO_INCREMENT for table `comment`
--
ALTER TABLE `comment`
  MODIFY `id` int(11) NOT NULL AUTO_INCREMENT, AUTO_INCREMENT=29;
--
-- AUTO_INCREMENT for table `form`
--
ALTER TABLE `form`
  MODIFY `id` int(11) NOT NULL AUTO_INCREMENT, AUTO_INCREMENT=12;
/*!40101 SET CHARACTER_SET_CLIENT=@OLD_CHARACTER_SET_CLIENT */;
/*!40101 SET CHARACTER_SET_RESULTS=@OLD_CHARACTER_SET_RESULTS */;
/*!40101 SET COLLATION_CONNECTION=@OLD_COLLATION_CONNECTION */;
